{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Proespm","text":"<p>Proespm is a Python-based tool designed to transform scientific data into interactive, shareable HTML reports. It supports automatic data processing for specific types of data, such as image corrections for scanning probe microscopy (SPM) data.</p> <p>If you intend to use <code>proespm</code>, have a look at the Installation and Usage sections.</p> <p>If you want to extend the program's functionality, see Extending functionality.</p>"},{"location":"#supported-methods","title":"Supported Methods","text":"<ul> <li> <p>Scanning Probe Microscopy (SPM):</p> <ul> <li>Specs Aarhus MUL (.mul, .flm)</li> <li>Omicron MATRIX (.mtrx)</li> <li>RHK SM4 (.sm4)</li> <li>Nanonis SXM (.sxm)</li> <li>Nanosurf STM and AFM (.nid)</li> <li>FAST module (.h5): fast scan, atom tracking, error topography, slow image,   high speed</li> </ul> </li> <li> <p>X-ray Photoelectron Spectroscopy (XPS):</p> <ul> <li>Omicron EIS (.txt)</li> </ul> </li> <li> <p>Auger Electron Spectroscopy (AES):</p> <ul> <li>STAIB WinSpectro (.vms, .dat)</li> </ul> </li> <li> <p>Quartz-Crystal Microbalance (QCMB):</p> <ul> <li>Inficon STM2 (.log)</li> </ul> </li> <li> <p>Cyclic Voltammetry (CV), Chronoamperometry (CA), Linear Sweep Voltammetry   (LSV), Impedence Spectroscopy (EIS):</p> <ul> <li>Nordic Electrochemistry EC4</li> <li>PalmSens (.csv, .pssession)</li> </ul> </li> <li> <p>Temperature Programmed Desorption (TPD):</p> <ul> <li>LabView (self written)</li> </ul> </li> <li> <p>Residual Gas Analyzer Software (RGA):</p> <ul> <li>Analog Scan</li> <li>Pressure vs Time Scan</li> </ul> </li> <li> <p>png, jpg images, e.g. LEED images</p> </li> </ul>"},{"location":"extend/","title":"Extending Functionality","text":"<p>This section provides information about how to extend the capability of <code>proespm</code> in order to process data files created by scietific measurements that are then included in the resulting HTML report. In short, the following steps are necessary:</p> <ol> <li>Create a class for your measurement file that implements the <code>Measurement</code>    interface</li> <li>Create a Jinja2 template for    your measurement</li> <li>Make sure your file extension is allowed</li> <li>Register your measurement file by file extension (and if needed additional    criteria) in the <code>create_measurement_objs</code> function in <code>processing.py</code></li> </ol> <p>These steps are further explained in the following accompanied by the practical example of the existing <code>Image</code> measurement which is responsible for handling simple PNG and JPEG images. The resulting entry in the HTML report will look like this:</p> <p></p> <p>See the full report example for context and other measurement entries.</p>"},{"location":"extend/#1-create-a-class-for-measurement-file","title":"1. Create a class for measurement file","text":"<p>For your class to implement the <code>Measurement</code> interface, it needs to define the following methods:</p> <pre><code>class Measurement(ABC):\n    \"\"\"Interface for a scientific measurement file.\"\"\"\n\n    @abstractmethod\n    def __init__(self, filepath: str) -&gt; None:\n        ...\n\n    @abstractmethod\n    def m_id(self) -&gt; str:\n        \"\"\"Unique measurement identifier.\"\"\"\n        ...\n\n    @abstractmethod\n    def datetime(self) -&gt; datetime.datetime:\n        \"\"\"Date and time of the measurement.\"\"\"\n        ...\n\n    @abstractmethod\n    def process(self, config: Config) -&gt; Self:\n        \"\"\"Processing of the measurement.\"\"\"\n        ...\n\n    @abstractmethod\n    def template_name(self) -&gt; str | None:\n        \"\"\"Name of the Jinja2 template used for HTML rendering.\"\"\"\n        ...\n</code></pre> <p>The <code>__init__</code> constructor takes the full path to the measurement file as an argument and is reposible for reading the file. Any additional fields that can lated be used in the HTML template are defined here. <code>m_id</code> needs to return a unique identifier for that measurement as a string. It is common to use the filename without extenstion. The <code>datetime</code> method returns the date and time of the measurement as a Python <code>datetime</code> object, which is used to order the measurements in the created HTML report chronologically. In <code>process</code>, any logic additional to reading the file should occur, e.g., image processing of SPM images or plot creation for spectroscopy data. In this method, you also have access to the <code>Config</code> which holds the information about the user-chosen colormap and color range. Last but not least, <code>template_name</code> needs to return the name of the Jinja2 template which will be responsible for rendering this measurement as HTML.</p> <p>In our example for PNG/JPEG images, the resulting class looks the following:</p> <pre><code>import base64\nimport os\nfrom datetime import datetime\nfrom typing import Self, final, override\n\nfrom proespm.fileinfo import Fileinfo\nfrom proespm.config import Config\nfrom proespm.measurement import Measurement\n\n\n@final\nclass Image(Measurement):\n    \"\"\"Class handeling image files (.png, .jpg, .jpeg)\"\"\"\n\n    def __init__(self, filepath: str) -&gt; None:\n        self.fileinfo = Fileinfo(filepath)\n\n        self.img_uri: str | None = None\n        self.slide_num: int | None = None\n\n    def encode_png(self):\n        \"\"\"Encodes an image to base64\n\n        Returns:\n            str: Data uri of the image\n        \"\"\"\n        with open(self.fileinfo.filepath, \"rb\") as f:\n            self.img_uri = (\n                f\"data:image/{self.fileinfo.fileext};base64, \"\n                + base64.b64encode(f.read()).decode(\"ascii\")\n            )\n\n    @override\n    def m_id(self) -&gt; str:\n        return self.fileinfo.filename\n\n    @override\n    def datetime(self) -&gt; datetime:\n        return datetime.fromtimestamp(os.path.getmtime(self.fileinfo.filepath))\n\n    @override\n    def process(self, config: Config) -&gt; Self:\n        self.encode_png()\n        return self\n\n    @override\n    def template_name(self) -&gt; str:\n        return \"image.j2\"\n</code></pre>"},{"location":"extend/#2-create-a-jinja2-template","title":"2. Create a Jinja2 template","text":"<p>Jinja2 is the template engine responsible for rendering HTML. For making your template findable for the engine, it needs to be located in the <code>templates</code> folder in <code>src/proespm</code>. The filename must match the string returned by the <code>template_name</code> method of your measurement class. In our example this is <code>image.j2</code>:</p> <pre><code>&lt;div class=\"measurement-row\"&gt;\n  &lt;div class=\"stm_image_fw\"&gt;\n    &lt;img id=\"{{ measurement.m_id() }}\" src=\"{{ measurement.img_uri }}\"  /&gt;\n  &lt;/div&gt;\n  &lt;div class=\"table_column\"&gt;\n    &lt;table style:\"width=100%\"&gt;\n      &lt;tr&gt;\n        &lt;th&gt;ID&lt;/th&gt;\n        &lt;td&gt;&lt;a href=\"file:///{{ measurement.fileinfo.filepath }}\"&gt;{{ measurement.m_id() }}&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;tr&gt;\n        &lt;th&gt;Date/time&lt;/th&gt;\n        &lt;td&gt;{{ measurement.datetime().strftime(\"%Y-%m-%d &lt;br&gt; %H:%M:%S\") }}&lt;/td&gt;\n      &lt;/tr&gt;\n    &lt;/table&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre> <p>The only thing which is needed for all measurements is the first occuring <code>&lt;div&gt;</code> which makes an entry in the resulting HTML report. In our example, the image is included as HTML with an <code>&lt;img&gt;</code> tag. In its <code>id</code> attribute you can see see the usage of the object <code>measurement</code> instanciated from our <code>Image</code> class where we use its <code>m_id</code>.</p> <p>Note</p> <p>The objects of all classes that implement the <code>Measurement</code> interface can always be accessed inside a template with the <code>measurement</code> variable.</p> <p>The <code>img_uri</code> field which was created in the <code>__init__</code> of <code>Image</code> and populated in <code>process</code> (via the call to <code>encode_png</code>) is of course used as the <code>src</code> of the <code>&lt;img&gt;</code>. As you can see, you have access to all fields and methods of the class. It is best practice though too keep the logic inside the template simple and implement as much as possible in the class itself.</p>"},{"location":"extend/#3-make-sure-your-file-extension-is-allowed","title":"3. Make sure your file extension is allowed","text":"<p>This is a simple one: Just open <code>config.py</code> and ensure the extension is listed in the <code>ALLOWED_FILE_TYPES</code> tuple in all-lowercase letters. We want our <code>Image</code> measurement to handle <code>\".png\"</code>, <code>\".jpg\"</code> and <code>\".jpeg\"</code> and as your can see, they are listed here:</p> <pre><code>ALLOWED_FILE_TYPES = (\n    # ...\n    \".png\",\n    \".jpg\",\n    \".jpeg\",\n    # ...\n)\n</code></pre>"},{"location":"extend/#4-register-your-measurement-file","title":"4. Register your measurement file","text":"<p>Open <code>processing.py</code> and have a look at the <code>create_measurement_objs</code> function, which essentially is a giant <code>match</code> statement. Here, you need to add a case for handeling the file type of your measurement file. For our example the following <code>case</code> is used:</p> <pre><code>def create_measurement_objs(\n    process_dir: str, _log: Callable[[str], None]\n) -&gt; list[Measurement]:\n    # ...\n        case \".png\" | \".jpg\" | \".jpeg\":\n            obj = Image(file_path)\n            measurement_objects.append(obj)\n\n    # ...\n</code></pre> <p>This simply means that for any file that has the above file extension and <code>Image</code> object is created and added the the list <code>measurement_objects</code>. In some cases, the file extension alone is not enough to unambiguously map a file extension to a class (think of multiple different measurement methods that all produce .csv-files). Have a look at other <code>case</code>s of the <code>match</code> statement to see what other possibilities exist to uniquely map a file to its corresponding class.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#using-prebuilt-binaries","title":"Using prebuilt binaries","text":"<p>The easiest way to get started with <code>proespm</code> is by downloading a executable binary for your operating system in the release section.</p>"},{"location":"installation/#using-uv","title":"Using uv","text":"<p>If you are comfortable with using Python from the command line, the best way is using uv. It will automatically download all required dependecies and a suitable Python interpreter when running the program with</p> <pre><code>uv run src/proespm/main.py\n</code></pre> <p>from the project's root directory.</p> <p>Furthermore, you can install the CLI with</p> <pre><code>uv tool install .\n</code></pre> <p>or</p> <pre><code>uv tool install --editable .\n</code></pre> <p>if you want to hack on it.</p>"},{"location":"installation/#using-pip","title":"Using pip","text":"<p>If you choose to use pip for installation, you have to make sure that you have Python version 3.13 or higher installed. Then you can create a virtual environment via</p> <pre><code>python3 -m venv .venv\n</code></pre> <p>and activate it with</p> <pre><code>. ./.venv/bin/activate\n</code></pre> <p>on UNIX-based systems. For other operating systems and more information about virtual environments, see the official documentation.</p> <p>Installation of the required dependecies is then done via</p> <pre><code>python3 -m pip install .\n</code></pre> <p>from the project's root.</p> <p>Now you should be able to run <code>proespm</code> with</p> <pre><code>python3 src/proespm/main.py\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#gui","title":"GUI","text":"<p>If you used uv for installation, you can navigate to the project root (the folder that contains the <code>pyproject.toml</code> file) and run <code>proespm</code> with:</p> <pre><code>uv run src/proespm/main.py\n</code></pre> <p>You can then see the following graphical user interface that contains everything for report creation:</p> <p></p> <p>With the Browse button you can choose the folder that contains your data files from measurements. You can also enter the disired path in the input field next to it.</p> <p>If you used the button, the output path gets populated automatically with the parent folder of the chosen folder. This is where the created report will be saved. You can edit this path also directly in the input field or choose another one with the Save As button.</p> <p>Next, you can choose the colormap for Scanning Probe Microscopy (SPM) image data. All matplotlib colormaps are available.</p> <p>Finally, you can choose the color range that is used to create SPM images. If you're not familiar with SPM, this basically allows to 'remove' outlier data points from the color range.</p> <p>You can then process your data and create a report by clicking the Start button.</p> <p>In the big area under the color range (log area), you will be presented with log information about which files are processed at the moment. Under that, the Save Log allows for saving this information to a file. This is especially useful if any errors occur during processing. If you report any errors, it is best to share a saved log file with the maintainers.</p> <p>After the processing finished, you can open the created HTML report in a browser.</p>"},{"location":"usage/#cli","title":"CLI","text":"<p>If you install the CLI via <code>uv tool install</code> you can simply run</p> <pre><code>proespm &lt;DATA-DIRECTORY&gt;\n</code></pre> <p>where <code>DATA-DIRECTORY</code> contains your measurement files of which the HTML report should be created. By default the report is created in the same directory where <code>DATA-DIRECTORY</code> is located with the basename of <code>DATA-DIRECTORY</code> and '_report.html' appended. This can be overwritten with the <code>-o</code> or <code>--output</code> option. The color map and color range of microscopy data can be configured via the <code>-c</code>/<code>--colormap</code> and <code>-s</code>/<code>--colorrange-start</code> and <code>-e</code>/<code>--colorrange-end</code> options, respectively. For a list of all options and their default values, use the <code>-h</code>/<code>--help</code> option.</p>"},{"location":"api/measurement/","title":"Measurement","text":""},{"location":"api/measurement/#proespm.measurement.Measurement","title":"<code>proespm.measurement.Measurement</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Interface for a scientific measurement file.</p> <p>Methods:</p> Name Description <code>datetime</code> <p>Date and time of the measurement.</p> <code>m_id</code> <p>Unique measurement identifier.</p> <code>process</code> <p>Processing of the measurement.</p> <code>template_name</code> <p>Name of the Jinja2 template used for HTML rendering.</p>"},{"location":"api/measurement/#proespm.measurement.Measurement.datetime","title":"<code>datetime() -&gt; datetime.datetime</code>  <code>abstractmethod</code>","text":"<p>Date and time of the measurement.</p>"},{"location":"api/measurement/#proespm.measurement.Measurement.m_id","title":"<code>m_id() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Unique measurement identifier.</p>"},{"location":"api/measurement/#proespm.measurement.Measurement.process","title":"<code>process(config: Config) -&gt; Self</code>  <code>abstractmethod</code>","text":"<p>Processing of the measurement.</p>"},{"location":"api/measurement/#proespm.measurement.Measurement.template_name","title":"<code>template_name() -&gt; str | None</code>  <code>abstractmethod</code>","text":"<p>Name of the Jinja2 template used for HTML rendering.</p>"}]}